The JavaScript Tree:
|
|‚îÄ‚îÄ Variables
| ‚îú‚îÄ‚îÄ var
| ‚îú‚îÄ‚îÄ let
| ‚îî‚îÄ‚îÄ const
|
|‚îÄ‚îÄ Data Types
| ‚îú‚îÄ‚îÄ String
| ‚îú‚îÄ‚îÄ Number
| ‚îú‚îÄ‚îÄ Boolean
| ‚îú‚îÄ‚îÄ Object
| ‚îú‚îÄ‚îÄ Array
| ‚îú‚îÄ‚îÄ Null
| ‚îî‚îÄ‚îÄ Undefined
|
|‚îÄ‚îÄ Operators
| ‚îú‚îÄ‚îÄ Arithmetic
| ‚îú‚îÄ‚îÄ Assignment
| ‚îú‚îÄ‚îÄ Comparison
| ‚îú‚îÄ‚îÄ Logical
| ‚îú‚îÄ‚îÄ Unary
| ‚îî‚îÄ‚îÄ Ternary (Conditional)
|
|‚îÄ‚îÄ Control Flow
| ‚îú‚îÄ‚îÄ if statement
| ‚îú‚îÄ‚îÄ else statement
| ‚îú‚îÄ‚îÄ else if statement
| ‚îú‚îÄ‚îÄ switch statement
| ‚îú‚îÄ‚îÄ for loop
| ‚îú‚îÄ‚îÄ while loop
| ‚îî‚îÄ‚îÄ do-while loop
|
|‚îÄ‚îÄ Functions
| ‚îú‚îÄ‚îÄ Function declaration
| ‚îú‚îÄ‚îÄ Function expression
| ‚îú‚îÄ‚îÄ Arrow function
| ‚îî‚îÄ‚îÄ IIFE (Immediately Invoked Function Expression)
|
|‚îÄ‚îÄ Scope
| ‚îú‚îÄ‚îÄ Global scope
| ‚îú‚îÄ‚îÄ Local scope
| ‚îú‚îÄ‚îÄ Block scope
| ‚îî‚îÄ‚îÄ Lexical scope
|
|‚îÄ‚îÄ Arrays
| ‚îú‚îÄ‚îÄ Array methods
| | ‚îú‚îÄ‚îÄ push()
| | ‚îú‚îÄ‚îÄ pop()
| | ‚îú‚îÄ‚îÄ shift()
| | ‚îú‚îÄ‚îÄ unshift()
| | ‚îú‚îÄ‚îÄ splice()
| | ‚îú‚îÄ‚îÄ slice()
| | ‚îî‚îÄ‚îÄ concat()
| ‚îî‚îÄ‚îÄ Array iteration
| ‚îú‚îÄ‚îÄ forEach()
| ‚îú‚îÄ‚îÄ map()
| ‚îú‚îÄ‚îÄ filter()
| ‚îî‚îÄ‚îÄ reduce()
|
|‚îÄ‚îÄ Objects
| ‚îú‚îÄ‚îÄ Object properties
| | ‚îú‚îÄ‚îÄ Dot notation
| | ‚îî‚îÄ‚îÄ Bracket notation
| ‚îú‚îÄ‚îÄ Object methods
| | ‚îú‚îÄ‚îÄ Object.keys()
| | ‚îú‚îÄ‚îÄ Object.values()
| | ‚îî‚îÄ‚îÄ Object.entries()
| ‚îî‚îÄ‚îÄ Object destructuring
|
|‚îÄ‚îÄ Promises
| ‚îú‚îÄ‚îÄ Promise states
| | ‚îú‚îÄ‚îÄ Pending
| | ‚îú‚îÄ‚îÄ Fulfilled
| | ‚îî‚îÄ‚îÄ Rejected
| ‚îú‚îÄ‚îÄ Promise methods
| | ‚îú‚îÄ‚îÄ then()
| | ‚îú‚îÄ‚îÄ catch()
| | ‚îî‚îÄ‚îÄ finally()
| ‚îî‚îÄ‚îÄ Promise.all()
|
|‚îÄ‚îÄ Asynchronous JavaScript
| ‚îú‚îÄ‚îÄ Callbacks
| ‚îú‚îÄ‚îÄ Promises
| ‚îî‚îÄ‚îÄ Async/Await
|
|‚îÄ‚îÄ Error Handling
| ‚îú‚îÄ‚îÄ try...catch statement
| ‚îî‚îÄ‚îÄ throw statement
|
|‚îÄ‚îÄ JSON (JavaScript Object Notation)
|
|‚îÄ‚îÄ Modules
| ‚îú‚îÄ‚îÄ import
| ‚îî‚îÄ‚îÄ export
|
|‚îÄ‚îÄ DOM Manipulation
| ‚îú‚îÄ‚îÄ Selecting elements
| ‚îú‚îÄ‚îÄ Modifying elements
| ‚îî‚îÄ‚îÄ Creating elements
|
|‚îÄ‚îÄ Events
| ‚îú‚îÄ‚îÄ Event listeners
| ‚îú‚îÄ‚îÄ Event propagation
| ‚îî‚îÄ‚îÄ Event delegation
|
|‚îÄ‚îÄ AJAX (Asynchronous JavaScript and XML)
|
|‚îÄ‚îÄ Fetch API
|
|‚îÄ‚îÄ ES6+ Features
| ‚îú‚îÄ‚îÄ Template literals
| ‚îú‚îÄ‚îÄ Destructuring assignment
| ‚îú‚îÄ‚îÄ Spread/rest operator
| ‚îú‚îÄ‚îÄ Arrow functions
| ‚îú‚îÄ‚îÄ Classes
| ‚îú‚îÄ‚îÄ let and const
| ‚îú‚îÄ‚îÄ Default parameters
| ‚îú‚îÄ‚îÄ Modules
| ‚îî‚îÄ‚îÄ Promises
|
|‚îÄ‚îÄ Web APIs
| ‚îú‚îÄ‚îÄ Local Storage
| ‚îú‚îÄ‚îÄ Session Storage
| ‚îî‚îÄ‚îÄ Web Storage API
|
|‚îÄ‚îÄ Libraries and Frameworks
| ‚îú‚îÄ‚îÄ React
| ‚îú‚îÄ‚îÄ Angular
| ‚îî‚îÄ‚îÄ Vue.js
|
|‚îÄ‚îÄ Debugging
| ‚îú‚îÄ‚îÄ Console.log()
| ‚îú‚îÄ‚îÄ Breakpoints
| ‚îî‚îÄ‚îÄ DevTools
|
|‚îÄ‚îÄ Others
| ‚îú‚îÄ‚îÄ Closures
| ‚îú‚îÄ‚îÄ Callbacks
| ‚îú‚îÄ‚îÄ Prototypes
| ‚îú‚îÄ‚îÄ this keyword
| ‚îú‚îÄ‚îÄ Hoisting
| ‚îî‚îÄ‚îÄ Strict mode
|
|____________ END __________________

________________________________________________

JavaScript was Complicated.
Learning these concepts made it easier for me:
ùü≠. ùó©ùóÆùóøùó∂ùóÆùóØùóπùó≤ùòÄ ùóÆùóªùó± ùóóùóÆùòÅùóÆ ùóßùòÜùóΩùó≤ùòÄ:
-> Declaration (`var`, `let`, `const`)
-> Primitive data types (strings, numbers, booleans, null, undefined)
-> Complex data types (arrays, objects, functions)
-> Type coercion and conversion
ùüÆ. ùó¢ùóΩùó≤ùóøùóÆùòÅùóºùóøùòÄ ùóÆùóªùó± ùóòùòÖùóΩùóøùó≤ùòÄùòÄùó∂ùóºùóªùòÄ:
-> Arithmetic operators (+, -, *, /, %)
-> Assignment operators (=, +=, -=, *=, /=, %=)
-> Comparison operators (==, ===, !=, !==, <, >, <=, >=)
-> Logical operators (&&, || , !)
-> Ternary operator (conditional operator)
ùüØ. ùóñùóºùóªùòÅùóøùóºùóπ ùóôùóπùóºùòÑ:
-> Conditional statements (`if`, `else if`, `else`)
-> Switch statement
-> Loops (`for`, `while`, `do-while`)
-> Break and continue statements
ùü∞. ùóôùòÇùóªùó∞ùòÅùó∂ùóºùóªùòÄ:
-> Function declaration and expression
-> Arrow functions
-> Parameters and arguments
-> Return statement
-> Scope (global scope, function scope, block scope)
-> Closures
-> Callback functions
ùü±. ùóîùóøùóøùóÆùòÜùòÄ ùóÆùóªùó± ùó¢ùóØùó∑ùó≤ùó∞ùòÅùòÄ:
-> Creation and initialization
-> Accessing and modifying elements
-> Array methods (push, pop, shift, unshift, splice, slice, concat, etc.)
-> Object properties and methods
-> JSON (JavaScript Object Notation)
ùü≤. ùóñùóπùóÆùòÄùòÄùó≤ùòÄ ùóÆùóªùó± ùó£ùóøùóºùòÅùóºùòÅùòÜùóΩùó≤ùòÄ:
-> Class syntax (constructor, methods, static methods)
-> Inheritance
-> Prototypal inheritance
-> Object.create() and Object.setPrototypeOf()
ùü≥. ùóòùóøùóøùóºùóø ùóõùóÆùóªùó±ùóπùó∂ùóªùó¥:
-> Try...catch statement
-> Throwing errors
-> Error objects (Error, SyntaxError, TypeError, etc.)
-> Error handling best practices
ùü¥. ùóîùòÄùòÜùóªùó∞ùóµùóøùóºùóªùóºùòÇùòÄ ùóùùóÆùòÉùóÆùó¶ùó∞ùóøùó∂ùóΩùòÅ:
-> Callbacks
-> Promises (creation, chaining, error handling)
-> Async/await syntax
-> Fetch API
-> setTimeout() and setInterval()
ùüµ. ùóóùó¢ùó† ùó†ùóÆùóªùó∂ùóΩùòÇùóπùóÆùòÅùó∂ùóºùóª:
-> Selecting DOM elements
-> Modifying element properties and attributes
-> Creating and removing elements
-> Traversing the DOM
ùü≠ùü¨. ùóòùòÉùó≤ùóªùòÅ ùóõùóÆùóªùó±ùóπùó∂ùóªùó¥:
-> Adding event listeners
-> Event objects
-> Event propagation (bubbling and capturing)
-> Event delegation
ùü≠ùü≠. ùó†ùóºùó±ùòÇùóπùó≤ùòÄ ùóÆùóªùó± ùó†ùóºùó±ùòÇùóπùóÆùóøùó∂ùòáùóÆùòÅùó∂ùóºùóª:
-> ES6 modules (import/export)
-> CommonJS modules (require/module.exports)
-> Module bundlers (Webpack, Rollup)
ùü≠ùüÆ. ùóïùóøùóºùòÑùòÄùó≤ùóø ùóñùóºùó∫ùóΩùóÆùòÅùó∂ùóØùó∂ùóπùó∂ùòÅùòÜ ùóÆùóªùó± ùó£ùó≤ùóøùó≥ùóºùóøùó∫ùóÆùóªùó∞ùó≤:
-> Cross-browser compatibility
-> Performance optimization techniques
-> Minification and code splitting
-> Lazy loading

_________________________________________________________


_____________________________________________________________

[6/3, 11:36 AM] Srikanth Shanmukesh: Here we go with the list
[6/3, 11:37 AM] Srikanth Shanmukesh: Javascripts arrays and objects built in usecases
[6/3, 11:38 AM] Srikanth Shanmukesh: Examples must read
[6/3, 11:38 AM] Srikanth Shanmukesh: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
[6/3, 11:38 AM] Srikanth Shanmukesh: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object
[6/3, 11:38 AM] Srikanth Shanmukesh: Json manipulations traversing lookups
[6/3, 11:39 AM] Srikanth Shanmukesh: Iife closures
[6/3, 11:39 AM] Srikanth Shanmukesh: Call and apply
[6/3, 11:39 AM] Srikanth Shanmukesh: Async and await
[6/3, 11:40 AM] Srikanth Shanmukesh: Basic es6 features, arrow let constant
[6/3, 11:40 AM] Srikanth Shanmukesh: Destructuring
[6/3, 11:40 AM] Srikanth Shanmukesh: Template literala
[6/3, 11:41 AM] Srikanth Shanmukesh: Spread and rest operators
[6/3, 11:41 AM] Srikanth Shanmukesh: Json to object etc.,
[6/3, 11:41 AM] Srikanth Shanmukesh: Coming to angular:
[6/3, 11:42 AM] Srikanth Shanmukesh: Components, data sharing in between compnents
[6/3, 11:42 AM] Srikanth Shanmukesh: Basic crud operations
[6/3, 11:42 AM] Srikanth Shanmukesh: Custom pipe example usecase
[6/3, 11:42 AM] Srikanth Shanmukesh: Behavior child
[6/3, 11:43 AM] Srikanth Shanmukesh: Rxjs operators
--------------
to learn----- typescript,tailwind,unittesting,redux,cloud,Mendix


Inline elements style or format particular content sections within block-level elements. For example, <span>, <a>, <strong>, and <em> take up only the appropriate width and do not begin on a new line. HTML Block components are used to organize a webpage's major content. They usually begin on a new line and fill the entire container width, e.g., <div>, <p>, <h1> to <h6>, <ul>, etc.

The main difference between ‚Äúdisplay: none‚Äù and ‚Äúvisibility: hidden‚Äù is that the former removes the element from the document flow, while the latter simply hides it. Elements with ‚Äúdisplay: none‚Äù are not visible and do not take up any space on the page, while elements with ‚Äúvisibility: hidden‚Äù are not visible but still take up space.

HTML5 now includes new components that make writing simple, quick code for intricate, dynamic, engaging, and successful websites possible. These new components add improved page layouts, functional features, and other enhancements.

<audio>: Embeds audio content directly into a webpage. It supports multiple audio formats (e.g., MP3, WAV, OGG).  It includes pause, play, and more.
<video>: Embeds video content into a webpage. It supports multiple video formats (e.g., MP4, WebM, Ogg).  It includes attributes like controls, autoplay, loop, and more.
<source>: Defines multiple media resources for <audio> and <video>. It allows browsers to choose the best-supported format.
<track>: Adds text tracks (e.g., captions, subtitles, descriptions) to <audio> or <video> elements. It supports attributes like kind, src, and label.
<embed>: Embeds external content, including multimedia like video or audio, and applications such as PDF viewers. Unlike <audio> and <video>, it is a general-purpose element.


Web Workers provide a simple way for web content to run scripts on background threads. The worker thread can complete tasks without affecting the user interface. They can also use the XMLHttpRequest and fetch() APIs for network requests. 

After it is created, a worker can post messages to an event handler provided by the JavaScript code to convey messages to that code. Web Workers enable long-running tasks to be executed without interrupting user interactions, keeping the UI responsive.

HTML5 is an improved version of HTML that incorporates multi-platform and multimedia compatibility capabilities while also improving HTML. Here are ways in which HTML5 is better than its previous versions:

HTML5 has enhanced the code structure, making it clearer and cleaner for programmers and non-programmers with its numerous new and modified tags. 
HTML5 offers a new cross-browser compatibility capability supported by several mainstream web browser versions rather than being limited to a particular platform or browser. 
HTML5 Web Storage reduces server costs by removing cookies and offering 5 MB of client-side storage space for data storage. This data is stored locally and is not transmitted via the server, making HTML5 Web Storage more secure than prior iterations. 
HTML5 can adjust attributes like controls, loop, autoplay, muted, src, height, width, etc., following the <audio> and <video> tags.
As you prepare for your job interview, we hope these HTML Interview Questions have provided more insight into the questions you will likely encounter.

---

css
________________________________________________
  <link rel="stylesheet" href="styles.css">
  
  Class is a way of using HTML elements for styling. They are not unique and have multiple elements. Whereas ID is unique and it can be assigned to a single element.
  
  This is one of the most frequently asked CSS interview questions. Z-index is used to specify the stack order of elements that overlap each other. Its default value is zero and can take both negative and positive values. A higher z-index value is stacked above the lower index element. It takes the following values- auto, number, initial, and inherit. 
  
  The font-related attributes are Font- style, variant, weight, family, size, etc. 
  
  Universal Selector, Element type Selector, ID selector, Class selector, Descendant combinatory, Child Combinator, General Sibling Combinator, Adjacent sibling combinator, and Attribute selector.
  
  CSS preprocessor is a tool used to enhance the basic functionality and let us use the complex logical syntax such as variables, functions, mixins, and code nesting within vanilla CSS scripts themselves.

Sass (Syntactically Awesome Style Sheets) uses .sass extension. It is used for indentation; it doesn‚Äôt use semicolons or curly brackets.
Less (Leener Stylesheets) uses .less extension. It is easy to add to any JavaScript Project by using NPM or less.js file. Here, @ is used to define the variables. 
Stylus provides great flexibility in writing syntax. It is able to use native CSS as well as the exclusion of brackets, colons, and semicolons. There is no need to use @ or $ to define the variables.
People use SASS, LESS, and Stylus in order to extend the basic functionality of vanilla CSS.

  VH and VW are CSS units used to measure viewport height and viewport width respectively in percentage form in the responsive design techniques. E.g. If the height of the browser is 1000px, then VH is 1/100 of the height of the viewport that is 1000px*(1/100) = 10px, which is the height of the browser.  The same applies to VW (viewport width).
  
  Block Elements are <div> and <p>. They usually start on a new line and can take space for an entire row or width.
Inline elements are <a>, <span>, <strong>, and <img> tags. They don't start on a new line. However, they appear on the same line as the content and tags beside them.
Inline block elements have padding and margins and set height and width values. Though, they are similar to inline elements.  

  Pseudo-classes are the type of pseudo-elements that don‚Äôt exist in a normal document tree. It allows selecting the regular elements under certain conditions especially when we try to hover over the link; the anchor tags are :link, :visited, :hover, :active, :focus

In this example, the color will be red on the anchor tag when it‚Äôs hovered.

/* mouse over link */

a:hover {

color: #FFOOFF;

}



Px (Pixel) is used for fine-grained control and alignment and not cascade. To get it sharp, we can use 1px or multiple of px.
Em is used to maintain relative size and responsive fonts. 1em = 16px having also the same font size. It is advisable to set the font size to 10px in common practice.
Pt (point) is a fixed-size unit that is used in print. 1pt = 1/72 inch.
Percentage (%) is used to set the font size with respect to the font size of the body. Thus, it is necessary to set the reasonable font size of the body.


Content-box inner , Padding-box and Border-box margin top

The CSS grid system is a type of powerful layout of 2 dimensional systems with respect to columns and rows.

center div

.container {
  display: flex;
  justify-content: center;
  align-items: center;
}

.container {
  display: grid;
  place-content: center;
  place-items: center;
}


CSS Grid Layout is a two-dimensional system along with rows and columns. It is used for large-sized layouts.
Flexbox is a Grid layout with a one-dimensional system either within a row or a column. It is used for the components of an application.
_______________________
Call invokes the function and allows you to pass in arguments one by one.
Apply invokes the function and allows you to pass in arguments as an array.
Bind returns a new function, allowing you to pass in a this array and any number of arguments.


assign constant is expression and normal function is declaration 


// Normal Function
const numbers = function(one, two) {}

// Arrow Function, with parentheses
const numbers = (one, two) => {}


const me = () => ({ name: "samantha" });

me(); // { name: "samantha" } ‚úÖ

const me = () => { name: "samantha" };

me(); // undefined üò±

___________________

React interview sudheerj
___________________________

https://notes.io/qDFj3
https://github.com/sudheerj/reactjs-interview-questions
https://github.com/ganqqwerty/123-Essential-JavaScript-Interview-Questions/tree/master
https://github.com/lukehoban/es6features
https://www.interviewbit.com/redux-interview-questions/

-------------------
Redux"


Flux is an application design paradigm just like the Model View Controller design pattern. Flux is nothing but a new kind of architecture that complements React and the concept of Unidirectional Data Flow

action- dispatcher-store-view cycle ---action--dispatcher
-
COMPARISON PARAMETER	REDUX	FLUX
Number of stores per application	Redux includes a single Store per application. Rather than placing state information in multiple Stores across the app, Redux keeps everything in one region of the application	Flux includes multiple Stores per application.
Architecture	Redux is an open-source JavaScript library used for creating User Interfaces.	Flux's architecture is designed to build client-side web apps.
Place where Business Logic of the Application Resides	In Redux, the business logic of the application resides in the Reducer.	In Flux, the business logic of the application resides in the Store.
-
redux makes read the data in redux store and dispatch action to  update the data,he purpose of Redux is to help applications scale well by providing means to manage the state via a unidirectional data flow model. 
-
6. State the core principles of Redux.
The core principles of Redux are as follows:

Single source of truth: The global state of our application is always put away in an object tree inside one store.
The state is read-only: The only way to change the state of our application is by emitting an action, an object explaining what has happened.
Changes are made with pure functions: This principle means that in order to define how the state tree is being transformed by the actions, we have to write pure reducers.
-
Some of the advantages of using Redux are as follows:

Redux provides extremely easy state transfer between the components.
The states are always predictable in Redux and its maintenance is relatively easy.
Debugging and testing code in Redux is simple through logging behaviour and status.
Redux provides great performance. It might occur to us that keeping the application's state global would result in bad performance. However, usually, that is not the case as React Redux implements a lot of performance optimizations internally so that our own connected component only re-renders when it actually needs to.
Redux also offers state persistence by storing the application's state to local storage and restoring it after a refresh.
-
Redux used to be great but if you have tried none of them, I would highly recommend using Redux-Toolkit. The only case where I may want you to stick to redux is when you're using class-based components, where Redux Toolkit does have some boilerplate (like Redux) and you may miss out decent support.

However with functional components, Redux toolkit is like Redux on steroids.

Reason for using Redux toolkit:

A lot lesser boilerplate code is required compared to Redux.

Redux hooks like useSelector and useDispatch make things so short and easy to use. [This is not specific to Redux toolkit, however, highlighting it here as it is extremely helpful to consume these hooks in functional component and might be helpful for those who are completely new to redux]

You don't need to do manual thunk setup as redux-toolkit comes with out of the box createAsyncThunk which enables you to perform async operations in very hassle free way.

getState is also very helpful in obtaining state variables across any of your actions or async operations.

Mutability might be considered as advantage or disadvantage, but if you're not too used to writing with spread operators, you might love this feature as well. Do straight assignments and let redux toolkit take care of mutability under the hoods.

current can be used to log your state anywhere in case you want to debug and understand where things are going wrong. (Of course, Redux debugger tools are great as well)

Prebuilt templates: you might want to use npx create-react-app my-app --template redux-typescript or if you're using it with next: yarn create next-app --example with-redux with-redux-app. It gives you a setup ready redux toolkit boiler plate and also contains a boiler plate of most important redux state management applications so that you could refer them to create your own slices very easily.

I have been using a lot of redux and initially it was a bit confusing but once you get a good command over redux toolkit and if you're using a lot of functional components, you probably would never go back to redux again.
-
Redux Toolkit is Redux's official, opinionated, batteries included toolset for efficient Redux development. It also consists of the most widely used Redux add-ons, for instance, Redux Thunk for asynchronous logic,  Reselect for writing selector functions and many more for making development easy for developers and saving them time
-
Some of the major features of Redux DevTools are as follows:

Redux DevTools is nothing but a time travel environment that makes it possible for us to live edit in Redux with a variety of functionalities like action replay, hot reloading, and customizable UI.
Redux DevTools makes it possible for us to inspect all the states and action payload. We can go back into the time simply by cancelling the actions.
Each stage action is re-evaluated in case we change the code of the reducer.
We can also continue our debug sessions across page reloads with the help of persistState() store enhancer.
-
Redux is an open-source library made using the scripting language JavaScript. Redux's primary use lies in managing and centralizing application state and it is usually used along with JavaScript libraries, for instance, React or Angular in order to build UIs (User Interfaces). It is a predictable state container for applications built using JavaScript. It is based on the Flux design pattern. Redux is very small in size (around 2 kilobytes) and has no dependencies.
-
mapStateToProps()	mapDispatchToProps()
The mapStateToProps() method is used to render the stored data to the component.	The mapDispatchToProps() method is used to render the action creators with props to the component.
The entirety of the results of the mapStateToProps() method is a plain object which is later merged into the component‚Äôs prop.	In the mapDispatchToProps() method, each action creator is wrapped in the dispatcher call so that they can be called upon directly and later merged into the component‚Äôs prop.
This method's use is to connect the redux state to the props of the react component.	This method's use is to connect redux actions to the react props.
-
const addingTodoAction = {
     type: 'ADD',
     payload: 'Do-homework'
}

In the Redux architecture, actions are nothing but the plain JavaScript objects which contain a type field. They can be thought of as an event that is used to describe something which has happened in the application. Actions contain only a tiny bit of information that is required to mention what has happened
-
Constants in Redux help us in easily finding all the usages of a particular functionality across our entire project when we are using an Integrated Development Environment (IDE). Using constants, we can avoid silly bugs caused because of typing errors or typos as it shows a "ReferenceError" whenever a typo is made
-
Reducers in Redux's architecture are pure functions that are used to take the previous state and an action and return the next state. Its syntax is given below:

 (previous_state, action) => new_state
 -
 Relay	Redux
The state originating from the server is taken care of by Relay.	All the states of the application are taken care of by Redux.
Relay can be used for caching and optimizing the data.	Redux is not responsible for handling data fetching (it can be done manually though).
-
The typical data flow in Redux starts with a call back from the User Interface component which dispatches an action with a payload. After that, the reducers intercept and receive the dispatched actions, generating a new application state. After that, the actions are propagated down through a hierarchy of components from the Redux store. 
-
UI-eventhandler-dispatch action - reducer intercepts-store the dispacthed actions-generates new application states-actions propagated from redux store as states 
-
Redux Saga functions as a separate thread in our programme which is solely responsible for side effects. Redux Saga is a redux middleware. In other words, it means that it can be started, paused, and aborted from the main application using standard Redux actions, has access to the entire Redux application state, and can also dispatch Redux actions
-
‚ÄúStore‚Äù in Redux is used to carry together all the states, reducers, and actions which create the app. Some of the responsibilities of the store are as follows:

The state of the current application from inside is held by the Redux Store.
We can access the current state using store.getState().
We can update the state using store.dispatch(action).
We can also register listener callbacks using the store.subscriber(listener)
replaceReducer(nextReducer)
-
In order to set the initial state in Redux, we have to pass the initial state as the second argument to createStore as shown below:

 const rootReducer = combineReducers({
  todos: todos,
  visibilityFilter: visibilityFilter
});

const initialState = {
  todos: [{id:100, name:'ritik', completed: true}]
};

const store = createStore(
  rootReducer,
  initialState
)
-
Using Redux Thunk middleware, we can write action creators returning a function instead of an action. This thunk can postpone the dispatch of an action, or do conditional dispatchment. The arguments passed to the inner function are the store methods dispatch and getState(). In the event of an action creator returning a function, the function gets executed by the Redux Thunk middleware and it does not have to be pure. In other words, the function is allowed to have side effects, including executing asynchronous API calls. It can even dispatch actions. Redux thunk is used to delay the dispatch of an action, or to dispatch in the event of a certain condition being met. At the time of dispatch of a function instead of an action object, if Redux Thunk middleware is enabled, the middleware will call that function with the dispatch method itself as the first argument

-

The workflow features in Redux are as follows:

Reset: The state of the store is allowed to be reset.
Revert: Revert or Rollback to the last committed state is allowed.
Sweep: Every disabled action which we have fired unintentionally will be removed.
Commit: The current state is made the initial state
-
import React from 'react';
import { connect } from 'react-redux';

 class App extends React.Component {
   render() {
     return <div>{this.props.containerData}</div>;
   }
 }

 function mapStateToProps(state) {
   return { containerData: state.appData };
 }

 export default connect(mapStateToProps)(App);

function mapStateToProps(state) {
  return { containerData: state.data };
}

export default connect(mapStateToProps)(App);

-
Redux Forms present in React and Redux help in enabling a form in React to use Redux for storing all of its states. They can be used with raw inputs in HTML5. Redux forms work extremely well with User Interface (UI) frameworks, for instance, Material UI, React Widgets, React Bootstrap and many more.

The major features of Redux forms are as follows:

Field values persistence through the Redux store.
Validation (synchronous/asynchronous) and submission.
Formatting, parsing and normalization of field values
-
Every Redux application has multiple top-level directories as given below:

Components: Components are used for ‚Äúdumb‚Äù React components unfamiliar with Redux.
Containers: Containers are used for ‚Äúsmart‚Äù React components that are connected to Redux.
Actions: Actions are used for all the action creators, where the file name should be corresponding to the part of the app.
Reducers: Reducers are used for all the reducers where the file name is corresponding to the state key.
Store: Stores are used for store initialization. This directory works best in small and mid-level size apps.
-
For accessing a redux store outside a react component, we can export the store from the module where it has been created with createStore as done in the following example:

store = createStore(reducer);
export default store;

-
React Redux	React Context API
In order to use React-Redux in our application, we need to code it separately and then merge it into the main project.	React Context can be used in the application directly.
-
The things which we should never do inside a reducer are as follows:

Modify the argument of the reducer
We should assure that we do not perform any side operations such as routing transitions, API calls, etc.
We should not call non-pure functions, for instance Date.now(), Math.random(), etc.

-
n order to add multiple middlewares to Redux, the usage of applyMiddleware can do the work. In applyMiddleware, we can pass every piece of middleware as a new argument. Therefore, our job is to just pass each piece of middleware that we want. In the example given below, we have added Redux Thunk and logger middlewares as an argument:

import { createStore, applyMiddleware } from 'redux'
const createStoreWithMiddleware = applyMiddleware(ReduxThunk, logger)(createStore);
-
Redux Thunk middleware allows you to write action creators that return a function instead of an action. The thunk can be used to delay the dispatch of an action, or to dispatch only if a certain condition is met. The inner function receives the store methods dispatch and getState as parameters.

-------------------------------------------|
--------------------------------------------
Machine coding

If I would prepare for Frontend interviews, I would master these 20 machine coding questions -

1. ùë©ùíñùíäùíçùíÖ ùíÇ ùëªùíêùíÖùíê ùë®ùíëùíë: Create a simple CRUD application for managing a list of tasks.

2. ùë∞ùíéùíëùíçùíÜùíéùíÜùíèùíï ùíÇ ùë¥ùíêùíÖùíÇùíç ùë™ùíêùíéùíëùíêùíèùíÜùíèùíï: Design a reusable modal component with open/close functionality.

3. ùë™ùíìùíÜùíÇùíïùíÜ ùíÇ ùë´ùíìùíêùíëùíÖùíêùíòùíè ùë¥ùíÜùíèùíñ: Build a dropdown menu that supports keyboard navigation.

4. ùë©ùíñùíäùíçùíÖ ùíÇ ùë∫ùíäùíéùíëùíçùíÜ ùë™ùíÇùíçùíÑùíñùíçùíÇùíïùíêùíì: Implement a basic calculator with addition, subtraction, multiplication, and division.

5. ùë∞ùíéùíÇùíàùíÜ ùë™ùíÇùíìùíêùíñùíîùíÜùíç/ùë∫ùíçùíäùíÖùíÜùíì: Create an image carousel that allows navigation through images with previous/next buttons.

6. ùë∞ùíèùíáùíäùíèùíäùíïùíÜ ùë∫ùíÑùíìùíêùíçùíç: Implement infinite scrolling on a list of items fetched from an API.

7. ùë∫ùíÜùíÇùíìùíÑùíâ ùë®ùíñùíïùíêùíéùíÇùíïùíÜ: Create an input field that suggests options based on user input.

8. ùëπùíÜùíîùíëùíêùíèùíîùíäùíóùíÜ ùëµùíÇùíóùíäùëîùíÇùíïùíäùíêùíè ùë©ùíÇùíì: Build a responsive navigation bar that collapses into a hamburger menu on smaller screens.

9. ùë≠ùíêùíìùíé ùëΩùíÇùíçùíäùíÖùíÇùíïùíäùíêùíè: Create a form with various input types and implement validation rules.

10. ùë´ùíÇùíïùíÇ ùëªùíÇùíÉùíçùíÜ ùíòùíäùíïùíâ ùë∫ùíêùíìùíïùíäùíèùíà ùíÇùíèùíÖ ùë∑ùíÇùíàùíäùíèùíÇùíïùíäùíêùíè: Design a table that displays data with options for sorting and pagination.

11. ùëªùíêùíàùíàùíçùíÜ ùë∫ùíòùíäùíïùíÑùíâ ùë™ùíêùíéùíëùíêùíèùíÜùíèùíï: Implement a toggle switch that changes state when clicked.

12. ùë≠ùíÜùíïùíÑùíâ ùë®ùë∑ùë∞ ùë´ùíÇùíïùíÇ ùíÇùíèùíÖ ùë´ùíäùíîùíëùíçùíÇùíö: Create a component that fetches data from an API and displays it.

13. ùë´ùíÇùíìùíå/ùë≥ùíäùíàùíâùíï ùë¥ùíêùíÖùíÜ ùëªùíêùíàùíàùíçùíÜ: Build a simple UI that allows users to switch between dark and light themes.

14. ùë´ùíìùíÇùíà ùíÇùíèùíÖ ùë´ùíìùíêùíë ùë≥ùíäùíîùíï: Implement a drag-and-drop interface for reordering items in a list.

15. ùëπùíÜùíÇùíç-ùíïùíäùíéùíÜ ùë™ùíâùíÇùíï ùë∞ùíèùíïùíÜùíìùíáùíÇùíÑùíÜ: Design a basic chat interface that simulates real-time messaging.

16. ùë∞ùíéùíÇùíàùíÜ ùëºùíëùíçùíêùíÇùíÖ ùíòùíäùíïùíâ ùë∑ùíìùíÜùíóùíäùíÜùíò: Create a component that allows users to upload an image and shows a preview.

17. ùë™ùíêùíñùíèùíïùíÖùíêùíòùíè ùëªùíäùíéùíÜùíì: Implement a countdown timer that counts down to a specified date.

18. ùë∫ùíïùíäùíÑùíåùíö ùëØùíÜùíÇùíÖùíÜùíì: Create a header that remains fixed at the top of the viewport when scrolling.

19. ùë™ùíñùíîùíïùíêùíé ùë∑ùíÇùíàùíäùíèùíÇùíïùíäùíêùíè: Build a custom pagination component for navigating through a set of data.

20. ùë∫ùíäùíéùíëùíçùíÜ ùë¥ùíÇùíìùíåùíÖùíêùíòùíè ùë¨ùíÖùíäùíïùíêùíì: Develop a basic text editor that converts Markdown syntax to HTML.

________________________________________________
React Interview

----------------------------------------------
Typescript

TypeScript is a superset of JavaScript. It is an object-oriented and tightly typed programming language. TypeScript code is transformed to JavaScript, which may be used in any environment that supports JavaScript, including browsers, Node.js, and your own applications.
-
TypeScript extends JavaScript with extra syntax to provide a more robust interface with your editor. TypeScript is a scripting language that is compatible with JavaScript and relies on type inference to deliver advanced functionality without the need for additional code.
-

var array_name[:datatype];        //declaration 

array_name = [val1,val2,valn..]   //initialization

Example:

let values: number[] = [];

values[0] = 10;
-
TypeScript is used to create both client-side and server-side JavaScript applications.
Because TypeScript adds more functionality and provides errors directly in the code, it can be used instead of JavaScript.
-
Problems are highlighted throughout development and at compilation time.
-
. List the disadvantages of TypeScript
It takes a long time to compile TypeScript code.
Abstract classes are not supported in TypeScript.
Converting TypeScript to JavaScript requires an additional compilation step.
Its type scheme is extremely complicated.
-
Let and const are the two methods to declare variables.
-
The access modifiers supported by TypeScript are:

Protected- All child classes and members have access to them, but the instance does not.
Private- Only members have access
Public- Members, child classes, and instances of the class have access to the public modifier.
-
he tsconfig.json file is a JSON format file where you may specify several options to inform the compiler how to compile a project. The presence of this file in the directory implies that it is the TypeScript project root
-
You can convert a string to a number by using parseInt(), parseFloat() and Number(‚Äò‚Äô) Method.
-
 What is meant by contextual typing?
When one side of the equation has type but the other does not, the TypeScript compiler determines the form. You can skip typing on the right side because TypeScript will figure it out for you. This reduces the amount of time spent typing code.
-
t's a syntax that's similar to XML and can be embedded. It must be converted into TypeScript that is valid. The JSX file with the.tsx extension is used.

JSX has an XML-like syntax that can be embedded. It is intended to be turned into legitimate JavaScript, though the semantics of that transformation will vary depending on the implementation. TypeScript allows you to embed JSX, type verify it, and compile it to JavaScript immediately
-
Static typing refers to a compiler that has recognisable variables, arguments, and object members at compile time. This aids in the early detection of faults. 
-
-------------
H to Z
-----------------
let count: number;
count = 10; // Valid
const PI: number; // Error: Const declarations
// must be initialized

-
const person = { name: "Alice"
, age: 30 };
person.age = 31; // Valid
person = { name: "Bob"
, age: 40 }; // Error:
// Cannot assign to 'person' because it is a
// constant
-
Type annotations: Explicitly declare the
type of a variable or function parameter.
Type inference: TypeScript automatically
infers types based on the assigned value
or usage context.
Example:
let count: number = 10;
Example:
let message = "Hello, TypeScript!";
// TypeScript infers message as string
-
null represents the intentional absence of
any object value.
undefined represents the absence of a
value for an uninitialized variable.
Examples:
Often used to indicate the absence of a
valid value or an error condition.
let result: null = null;
let data: undefined = undefined
-
Arrays: represent ordered collections of
values.
Example: let numbers: number[] = [1, 2, 3,
4, 5];
Arrays can store values of the same type,
such as numbers or strings, or a
combination of different types.
Example: let mixedArray: (number |
string)[] = [1,
"two"
, 3, "four"];

-
Objects: Represent collections of keyvalue pairs.
Example: let person: { name: string, age:
number } = { name: "John"
, age: 25 };
-
let user: {
name: string,
address: {
street: string,
city: string
}
} = {
name: "John"
,
address: {
street: "123 Main St"
,
city: "New York"
}
};
-
Functions in TypeScript can have
parameter types and return types for type
safety.
function addNumbers(a: number, b: number): number {
returna+b;
}
-
function greet(name: string, greeting?: string): void {
if (greeting) {
console.log(`${greeting}, ${name}!`);
} else {
console.log(`Hello, ${name}!`);
}
}
greet("John"); // Output: Hello, John!
greet("Jane"
,
"Good morning");
// Output: Good morning, Jane!
-
Union types (|): Combine multiple types,
allowing a value to have different possible
types.
Example:
let value: string | number = "Hello";
-
Creating Custom Types: The "type"
keyword allows creating type aliases for
custom types.
The type keyword helps in annotating and
reusing union types.
Example: type Age = number;
Example:
type Status = "active" | "inactive";
let iAmActive: Status = "active";
let iAmInactive: Status = "inactive"
-
Creating Custom Types: The "type"
keyword allows creating type aliases for
custom types.
The type keyword helps in annotating and
reusing union types.
Example: type Age = number;
Example:
type Status = "active" | "inactive";
let iAmActive: Status = "active";
let iAmInactive: Status = "inactive"
-
The any type is a special type in
TypeScript that represents a value of any
type.
It allows variables to bypass type
checking and enables dynamic behavior.
Use the any type sparingly, as it sacrifices
type safety and can lead to potential
runtime errors.
Example:
any
¬© Ritik Banger
let data: any = 10;
data = "Hello";
data = true;
-
The unknown type represents a value
whose type is unknown at compile-time.
Variables of type unknown can hold
values of any type but require type
checking or assertions for safe usage.
It provides a safer alternative to the any
type when dealing with dynamic or
uncertain data.
Example:
unknown
¬© Ritik Banger
let value: unknown = "Hello";
let length: number;
if (typeof value === "string") {
length = value.length;
} else {
length = 0;
}
-
The never type represents a type that
never occurs.
It is used to indicate values that cannot
happen or functions that never return.
It is particularly useful in exhaustiveness
checking and enforcing strict handling of
all possible cases.
Functions returning never must either
throw an error or have an infinite loop.
Example:
never
¬© Ritik Banger
function throwError(): never {
throw new Error("An error occurred");
}
throwError(); // Function that throws an
error and never returns.
-
The void type represents the absence of
any type in TypeScript.
It is commonly used as the return type of
functions that do not explicitly return a
value.
Variables of type void can only be
assigned undefined or null.
Functions returning never must either
throw an error or have an infinite loop.
Example:
void
¬© Ritik Banger
function logMessage(message: string): void {
console.log(message);
}
logMessage("Hello, TypeScript!");
// Prints "Hello, TypeScript!"
--
